package define;

public class ExceptionHandling {
/*
	
	** 프로그램에서의 오류 분류 
	1.Error
	1) 물리적 에러 : 문법적인 오류로 프로그램이 실행이 안되는 경우 
	   - IDE에서는 물리적인 에러가 발생하면 빨간색으로 표시를 해줍니다 
	   - IDE에서는 물리적 에러가 발생하덛라도 실행되는 경우가 있는 데 이 경우는 성공한 마지막 프로그램을 
	     실행하는 경우가 대부분입니다. 
	   - 물리적 오류가 발생한 경우에는 반드시 수정을 해야 합니다. 
	 
	 2) 논리적 에러:문법적인 오류가 없어서 프로그램이 실행되는데 원하지 않는 또는 잘못된 결과가  나오는 경우 
	   - 프로그램을 디버깅(논리적 오류나 예외를 찾기 위해서 프로그램을 실행하면서 데이터를 중간 중간 
	     확인해 보는 과정)을 해서 오류가 발생하는 로직을 찾아서 수정  
	   - 디버깅을하는 방법은 직접 중간중간 로그를 출력해 보는 방법이 있고 디버깅 프로그램을 이용 
	     (break point 를 만들어서 프로그램 중간중간 중단하도록 만들고  그때까지의 변수의 값을 확인 ) 
	 
	2. 예외(Exception) 
	    - 문법적인 오류는 없어서 실행은 되지만 특정한 상황을 만나면 프로그램이 오류를 발생시키면서 
	      중단되는 현상 
	    - 문법적인 오류 체크는 자료형을 가지고 하는 것이지 값을 가지고 하는게 아닙니다. 
	   
	     1/2   : 에러가 아님 
	     1/0  : 에러가 아님 - 예외 
	     1/"0" : 에러 
	  
	    - 예외도 2가지로 분류할 수 있는데 개발자가 해결가능한 예외가 있고 해결 불가능한 예외가 있습니다. 
	    - 0으로 나누는 상황은 예외처리를 해서 나눗셈을 하지 않도록 개발자가 해결가능하지만 메모리 부족 
	      같은 예외는 개발자가 해결할 수 있는 상황이 아닙니다.   
	   
	  3. 단언(Assertion) 
	    - 개발자가 특정조건을 만족하지 않으면 강제로 예외를 발생시켜서 프로그램을 중단시키는 것 
	    - 실행 환경을 체크해서 실행하도록 하는 것과 보안을 위해서 특정 조건을 만족하는지 확인해 보는 것 
	    
	   ** 예외 (Exception) 처리(Handling) 
	   1. 예외처리의 목적 
	   - 예외가 발생한 내용을 기록하기 위해서 - 유지보수나 프로그램을 수정하는 데 도움이 됩니다. 
	     웹사이트에서 사용을 하다가 문제가 생겼을대 브라우저가 오류 보고 보냄이라는 메세지를 출력할때 
	     를  보셨을 텐데 그게 예외 내용을 기록하는 것입니다.  
	   - 예외가 발생했더라도 프로그램을 계속 실행하기 위해서
	     서버는 예외가 발생했다고 해서 무조건 중지 되면  안됩니다.
	     다른 클라이언트나 서버 자체에 크게 해가 되지 않는다면 계속 실행하는 것이 좋습니다.  
	     
	     2. 예외 관련 클래스
		     1) java.lang.Throwable 클래스가 예외 관련 클래스 중에서 최상위 클래스 
		       Class Throwable     
				java.lang.Object    
				    java.lang.Throwable      : Objcet클래스로부터 상속
				
				All Implemented Interfaces:
				Serializable     : 이 클래스가 Serializable 인터페이스를 구현 
				
				Direct Known Subclasses:
				Error, Exception   : Error클래스와 Exception클래스가 Throwable을 직접 상속받음 
		      
		       => String getMessage() : 예외의 내용을 문자열로 리턴해주는 메소드 
		       => void printStackTrace() : 예외가 발생한 지점을 역추척해서 콘솔에 출력해주는 메소드 
		     
		     2) Error & Exception 
			     => Error 는 메모리 부족과 같은 복구할수 없는 치명적인 예외 
			     => Exception 은 해결 가능한 예외 
			     => 보통의 경우는 예외의 최상클래스를 Exception을 해석하는 경우가 많습니다. 
	        
	        3) Exception의 분류 
		        => RuntimeException: Java compiler가 체크하지 않는 예외로 예외 처리구문을 작성하지 
		             않아도 되는 예외 - 실행시 발생하는 예외 
		        => Non RuntimeException : Java Compiler가 체크하는 예외로 예외 처리구문을 반드시 
		           작성해야하는 예외 - 실행하기 위한 조건을 검사해야 하는 예외  	          
		          ex) 인터넷에서 데이터를 다운로드 받으려면 URL을 만들어야 하는데 적합한URL인지 확인하는 예외 
		   
		    4) 많이 발생하는 예외 클래스 
			 
			   => NullPointException: 참조형 변수가 메모리 할당을 하지 않은 상태에서.을 이용해서 
			       자신의 속성이나메소드를 호출하는 경우 
		      
		      => InstantiationException: 인터페이스나 추상클래스를 가지고 객체를 생성하려고 할때 
		          발생하는 경우 
		         
		      => IOException: 파일이나 스트림이 존재하지 않는데 읽을려고 할 때 발생 
		     
		      => ArithmeticExceptiom: 잘못된 산술연산을 했을 때 발생 
		     
		      => ArrayIndexOutOfBoundsException: 배열이나 list의 첨자가 범위를 넘어선 경우 
		      
		      => NumberformatException : 숫자 데이터가 아닌데 숫자로 변경할려고 하는 경우 
		        이 경우는 공백이 포함된 데이터나 없는 데이터를 숫자로 변경하려고 하는 경우  
		       
		     => ClassCastException: 형 변환이 안되는 것을 강제 형 변환한 경우 
		  
		 3. 예외처리 방법 
			 1) 예외가 발생한 메소드에서 처리하는 방법
			 2) 예외를 호출한 곳으로 던져서 처리하는 방법  
			 
		 4. 예외처리 구문 
		     try {
		        // 필수 
		          예외가 발생할 가능성이 있는 구문 
		     } catch(예외클래스 변수명) { 
		        // 필수는 아니고 여러개 작성 가능 
		           예외클래스에 해당하는 예외가 발생했을때 수행할 내용 
		     }
		    finally{
		      // 필수는 아니고 1개만 작성 가능 
		        예외발생 여부에 상관없이 무조건 수행할 내용 
		    }
		       => catch finally를 모두 생략할 수는 없음 
		       => 각각은 독립적인 구문: try에서 만든 변수를 catch에서 사용할 수는 없습니다. 
		       => finally에는 외부자원(파일,네트워크, 데이터베이스등)을 사용한 경우 해제하는 코드를 
		            작성하는 것이 일반적입니다. 
		           외부자원을 사용할 때는 2개의 링크가 설정됩니다. 
		           링크를 양쪽에서 모두 해제하지 않으면 링크가 남아있어서 사용 중이 됩니다. 
		           문제가 발생해서 다음 로직으로 넘어갈때 해제를 하고 넘어가야 합니다. 
	         
	         => catch를 여러 개 사용할 때 주의할 점은 앞부분에 나오는 예외 클래스가 뒤에 나오는 예외클래스
	            보다 상위클래스면 안됩니다. 
	            객체지향 프로그래밍에서는 상위 클래스의 참조형 변수에 하위클래스의 객체 참조를 
	            대입할수 있기 때문입니다.
	        
	        => 예외클래스들을 묶어서 catch를 만들고자 할 때는 각 클래스이름을 직접 사용하지 말고 
	            상위클래스이름을 이용하면 됩니다. 
	           
	    5. 예외를 강제로 발생시키기 
		    => 원래는 예외가 아닌데 예외를 강제로 발생시키는 것입니다. 
		    단언을 구현하는 방법이기도 합니다. 
		    특정 조건을 만족하지 않으면 예외를 발생시켜 프로그램을 중단시킬수 있습니다.        
		    프로그램을 중지 시키는 메소드는 System클래스에 있는 exit라는 static메소드 이고 이 메소드의 
		    매개변수는 정수인데 0이면 정상 종료이고 그 이외의 숫자이면 그 숫자에 해당하는 에러가 발생해서
		    종료되는 것입니다.        
	    
	     6. 예외를 직접처리하지 않고 호출한 곳에서 처리하도록 하기 
	        메소드 원형() throws 예외클래스이름 { 
	        
	        }
	       => 이런 형태로 만들어진 메소드는 메소드를 호출한 곳에서 예외를 처리해주어야 합니다.
	       예외처리를 하지 않으면 에러가 발생합니다. 
	       
	       **1부터 10까지 1초씩 대기하면서 출력 
	       => 현재 작업을 특정 시간동안 대기시켜주는 메소드 java.lang.Thread클래스의 sleep이라는 
	       메소드 입니다. 	       
	        
	        // 1-10까지 대기하면서 출력하기 
			for(int i = 1; i <= 10; i++) {			
				System.out.printf("i : %d\n", i);
				//1초씩 대기		
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {
					    System.out.printf("인터럽트 예외 발생\n");
					    System.out.printf("예외:%s\n", e.getMessage());
						e.printStackTrace();
					}				
			 }
	      => Thread 클래스의 sleep이라는 메소드는 throws InterruptedExceptiom이 선언되어 있어서 
	      호출하는곳에서 InterruptedException을 처리해 주어야 합니다.
	      직접처리하는 방법도 있고 또 throw를 이용해서 다른 곳에서 처리하도록 할 수 있습니다.
	      좋지 못한 방법중의 하나는 main에 throws예외클래스 이름을 추가하는 것입니다.
	      main은 운영체제가 호출하는 메소드 입니다. 
	      main에 throws를 추가하게 되면 예외처리를 하지 않아도 됩니다.
	      어떤 예외가 언제 어디서 발생했는지 알 수 없게 되서 추천하지 않는 방법입니다.
	      자바 교재들에서는 main에 throws를 추가하는 경우가 있는데 이 경우는 예외처리를 설명하지 않고 
	      예외처리를 해야하는 메소드를 사용해보기 위해서 입니다.       
	  
	  7. 사용자 정의 예외 클래스 
		  => 사용자가 만든 예외 클래스 
		  => Exception클래스를 상속 받아서 생성 
		  => 상위클래스 생성자에게 문자열을 넘겨주면 getMessage()를 호출할 때 그 문자열이 리턴됩니다.     
     
     8. try-with-resources 
	     try(객체 생성) {
	         객체 사용 
	      }
	      => try()안에서 AutoCloseable이 implements된 클래스의 객체를 생성하면 close()를 호출할 필요가 
	      없어집니다. 
	      => 이 구문이 있기 전까지는 try외부에 파일이나 네트워크 데이터베이스에 관련된 변수를 만들고 try
	      에서 객체를 생성해서 대입하고 catch에서 예외처리를 하고 finally에서 close()를 호출해서 정리를 
	      했습니다. 
	      => try - with -resources를 이용하게 예외 발생 여부에 상관없이 자동으로 close()를 호출합니다. 
	      최근의 프로그래밍언어들에서는 with를 이용해서 이렇게 처리하는 경우가 많습니다. 
	      => java 1.7버전에서부터 지원 웹프로젝트를 생성하다 보면 IDE중에는 java 1.5 버전을 
	      사용하는 프로젝트를 만들어주는 경우가 있습니다.
	      이런 경우에는 1.7이상 사용하도록 변경해 놓고 사용하던가 아니면 사용을 하지 않아야 합니다.
	        
	** 중요한 내용 
	1. Throws가 있으면 호출한 곳에서 예외를 처리해야한다. 
	
    2. try - catch - finally 의 역할 
		      
    3. try - with - resources 구문  
	      
	      
	      
	     	      
*/	  
}
